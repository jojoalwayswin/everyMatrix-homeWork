package http.intercepter;import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import http.annotation.GetMapping;import http.annotation.PostMapping;import http.annotation.RequestBody;import http.annotation.RequestParam;import manager.ExecutorManager;import manager.RouteManager;import java.io.*;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.nio.charset.StandardCharsets;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;/** * @author zhangshu * @ClassName AnnotationHandler * @description: AnnotationHandler * @date 2025年04月29日 * @version: 1.0 */public class HomeworkHttpHandler implements HttpHandler {    private static AtomicInteger connectionCount = new AtomicInteger(0);    @Override    public void handle(HttpExchange exchange) throws IOException {        String path = exchange.getRequestURI().toString();        String method = exchange.getRequestMethod();        int currentCount = connectionCount.incrementAndGet();        System.out.println("Connection Count: " + currentCount);        if ("GET".equals(method)) {            Method handlerMethod = RouteManager.findGetMethod(path);            if (handlerMethod != null) {                Map<String, String> queryParams = RouteManager.matchParams(handlerMethod.getAnnotation(GetMapping.class).value(), path);                ExecutorManager.getExecutor().execute(() -> {                    try {                        Object result = invokeMethodWithParams(handlerMethod, queryParams, null);                        sendResponse(exchange, 200, result);                    } catch (InvocationTargetException e) {                        e.printStackTrace();                        String message = e.getTargetException().getMessage();                        sendErrorResponse(exchange, 500, message != null ? message : "Internal Server Error");                    } catch (Exception e) {                        e.printStackTrace();                        sendErrorResponse(exchange, 500, e.getMessage());                    }finally {                        connectionCount.decrementAndGet();                    }                });            } else {                sendErrorResponse(exchange, 404, "Not Found");            }        } else if ("POST".equals(method)) {            Method handlerMethod = RouteManager.findPostMethod(path);            if (handlerMethod != null) {                Map<String, String> queryParams = RouteManager.matchParams(handlerMethod.getAnnotation(PostMapping.class).value(), path);                String requestBody = readRequestBody(exchange.getRequestBody());                ExecutorManager.getExecutor().execute(() -> {                    try {                        Object result = invokeMethodWithParams(handlerMethod, queryParams, requestBody);                        sendResponse(exchange, 200, result != null ? result.toString() : "");                    } catch (InvocationTargetException e) {                        e.printStackTrace();                        String message = e.getTargetException().getMessage();                        sendErrorResponse(exchange, 500, message != null ? message : "Internal Server Error");                    } catch (Exception e) {                        e.printStackTrace();                        sendErrorResponse(exchange, 500, e.getMessage());                    }finally {                        connectionCount.decrementAndGet();                    }                });            } else {                sendErrorResponse(exchange, 404, "Not Found");            }        } else {            sendErrorResponse(exchange, 405, "Method Not Allowed");        }    }    private void sendErrorResponse(HttpExchange exchange, int statusCode, String message) {        try {            sendResponse(exchange, statusCode, message != null ? message : "Unknown error");        } catch (Exception e) {            sendErrorResponse(exchange, 500, "Internal Server Error");        }    }    private String readRequestBody(InputStream inputStream) throws IOException {        StringBuilder stringBuilder = new StringBuilder();        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));        String line;        while ((line = reader.readLine()) != null) {            stringBuilder.append(line);        }        return stringBuilder.toString();    }    private void sendResponse(HttpExchange exchange, int statusCode, Object response) throws IOException {        if (response == null){            response = "";        }        byte[] bytes = response.toString().getBytes(StandardCharsets.UTF_8);        exchange.sendResponseHeaders(statusCode, bytes.length);        OutputStream os = exchange.getResponseBody();        os.write(bytes);        os.close();    }    private Object invokeMethodWithParams( Method method, Map<String, String> queryParams, String requestBody) throws IllegalAccessException, InvocationTargetException {        Parameter[] parameters = method.getParameters();        Object[] params = new Object[parameters.length];        for (int i = 0; i < parameters.length; i++) {            Parameter parameter = parameters[i];            Object  paramValue;            if (parameter.isAnnotationPresent(RequestParam.class)) {                RequestParam requestParam = parameter.getAnnotation(RequestParam.class);                String paramName = null;                if (requestParam != null) {                    paramName = requestParam.value();                }                if (queryParams != null && queryParams.containsKey(paramName)) {                    if (parameter.getType() == int.class){                        paramValue = Integer.parseInt(queryParams.get(paramName)) ;                    }else if (parameter.getType() == String.class){                        paramValue = queryParams.get(paramName) ;                    }else {                        throw new IllegalArgumentException("Unsupported parameter type: " + parameter.getType());                    }                    params[i] = paramValue;                }            } else if (parameter.isAnnotationPresent(RequestBody.class)) {                if (parameter.getType() == int.class){                    paramValue = Integer.parseInt(requestBody) ;                }else if (parameter.getType() == String.class){                    paramValue = requestBody;                    if (queryParams != null) {                        paramValue = queryParams.get(requestBody) ;                    }                }else {                    throw new IllegalArgumentException("Unsupported parameter type: " + parameter.getType());                }                params[i] = paramValue;            } else {                throw new IllegalArgumentException("Unsupported parameter type: " + parameter.getType());            }        }        return method.invoke(RouteManager.findController(method), params);    }}